<!DOCTYPE html>
<html>
    <head>
<meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/><meta name="theme-color" content="#3b3e43"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no"/><title>算法：数组 - echo洋</title><meta name="description" content="最常见的结构-数组，与数组应用相关的算法题。"/><meta property="og:description" content="最常见的结构-数组，与数组应用相关的算法题。"/>    <meta name="keywords" content="Solo,Java,博客,开源"/><link rel="dns-prefetch" href="https://gyyspace.github.io"/><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"/><link rel="preconnect" href="https://gyyspace.github.io"><link rel="icon" type="image/png" href="https://b3log.org/images/brand/solo-128.png"/><link rel="apple-touch-icon" href="https://b3log.org/images/brand/solo-128.png"><link rel="shortcut icon" type="image/x-icon" href="https://b3log.org/images/brand/solo-128.png"><meta name="copyright" content="B3log"/><meta http-equiv="Window-target" content="_top"/><meta property="og:locale" content="zh_CN"/><meta property="og:title" content="算法：数组 - echo洋"/><meta property="og:site_name" content="echo洋"/><meta property="og:url"      content="https://gyyspace.github.io/articles/2024/07/21/1721546193766.html?"/><meta property="og:image" content="https://b3log.org/images/brand/solo-128.png"/><link rel="search" type="application/opensearchdescription+xml" title="算法：数组 - echo洋" href="/opensearch.xml"><link href="https://gyyspace.github.io/rss.xml" title="RSS" type="application/rss+xml" rel="alternate"/><link rel="manifest" href="https://gyyspace.github.io/manifest.json">        <link rel="canonical" href="https://gyyspace.github.io/articles/2024/07/21/1721546193766.html">            <link rel="stylesheet"
                  href="https://gyyspace.github.io/skins/favourite/css/base.css?1721540580809"/>
            <link rel="prev" title="算法：数学知识" href="https://gyyspace.github.io/articles/2024/07/21/1721546109578.html">
            <link rel="next" title="并发编程：进程、线程" href="https://gyyspace.github.io/articles/2024/07/21/1721546762645.html">
    <script src="https://gyyspace.github.io/js/lib/vditor/dist/js/icons/ant.js?v=3.9.7" async="" id="vditorIconScript"></script>    </head>
    <body>
        
<div class="top">
    <div id="navigation">
        <a rel="nofollow" href="https://gyyspace.github.io" class="home">首页</a>
        <a href="https://gyyspace.github.io/tags.html" class="about">标签墙</a>
            <a href="/tags/Redis" class="Guestbook" target="_blank"
               class="Redis 的设计与实现">Redis 的设计与实现</a>
            <a href="/tags/算法" class="Guestbook" target="_blank"
               class="算法">算法</a>
        <a rel="alternate" href="https://gyyspace.github.io/rss.xml" class="classifiche">RSS</a>
    </div>
    <div class="thinks"></div>
</div>        <div class="wrapper">
            <div class="content">
<div class="header">
    <h1 class="title">
        <a href="https://gyyspace.github.io" id="logoTitle" >
            echo洋
        </a>
    </h1>
    <span class="sub-title"></span>
</div>                <div class="roundtop"></div>
                <div class="body">
                    <div class="left main">
                        <div class="article">
                            <h2 class="article-title">
                                <a class="no-underline" href="https://gyyspace.github.io/articles/2024/07/21/1721546193766.html">
                                    算法：数组
                                </a>
                            </h2>
                            <div class="posttime-blue">
                                <div class="posttime-MY">
                                    2024-07
                                </div>
                                <div class="posttime-D">
                                    21
                                </div>
                            </div>
                            <div class="article-abstract">
                                <div class="note">
                                    <div class="corner"></div>
                                    <div class="substance vditor-reset">
                                        <p><img src="https://b3logfile.com/bing/20230823.jpg?imageView2/1/w/960/h/540/interlace/1/q/100" alt=""></p>
<h1 id="toc_h1_0">数组相关题目</h1>
<h2 id="toc_h2_1"><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank">56. 合并区间</a></h2>
<p><strong>Arrays.sort的比较器：</strong></p>
<pre><code>//第一种：
Arrays.sort(arr, new Comparator&lt;int[]&gt;() {
    @Override
    public int compare(int[] a, int[] b) {
        // TODO Auto-generated method stub
        return a[0] - b[0];
    }
});
//第二种：lambda表达式
Arrays.sort(arr, (a,b) -&gt; a[0] - b[0]);
//第三种：
Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a[0]));
</code></pre>
<p><strong>解法：先进行排序，然后遍历将存在公共区间的合并。</strong></p>
<pre><code>public int[][] merge(int[][] arr) {
 &nbsp; &nbsp; &nbsp; &nbsp;if(arr == null || arr.length&lt;=1) {
             return arr;
        }
 &nbsp; &nbsp; &nbsp; &nbsp;List&lt;int[]&gt; list = new ArrayList&lt;&gt;();

        Arrays.sort(arr, new Comparator&lt;int[]&gt;() {
            @Override
            public int compare(int[] a, int[] b) {
                // TODO Auto-generated method stub
                return a[0] - b[0];
            }
        });
 &nbsp; &nbsp; &nbsp; &nbsp;//Lambda表达式
        //Arrays.sort(arr, (a,b) -&gt; a[0] - b[0]);

        for (int i = 0; i &lt; arr.length; i++) {
            int left = arr[i][0];
            int right = arr[i][1];
            while (i+1 &lt; arr.length &amp;&amp; right &gt;= arr[i+1][0]) {
                right = Math.max(right, arr[i+1][1]);
                i++;
            }
            list.add(new int[] {left, right});
        }
        return list.toArray(new int[list.size()][2]);
 &nbsp;  }
</code></pre>
<h2 id="toc_h2_2"><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank">435. 无重叠区间</a></h2>
<h2 id="toc_h2_3"><a href="https://leetcode-cn.com/problems/zero-matrix-lcci/" target="_blank">面试题 01.08. 零矩阵</a></h2>
<pre><code>public void setZeroes(int[][] matrix) {
 &nbsp; &nbsp; &nbsp; boolean col = false;
        boolean row = false;
        int n = matrix.length, m = matrix[0].length;
        for (int i = 0; i &lt; n; i++) {
            if (matrix[i][0] == 0) {
                col = true;
            }
        }
        for (int i = 0; i &lt; m; i++) {
            if (matrix[0][i] == 0) {
                row = true;
            }
        }
        for (int i = 1; i &lt;n; i++) {
            for (int j = 1; j &lt;m; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = matrix[0][j] = 0;
                }
            }
        }
        for (int i = 1; i &lt;n; i++) {
            for (int j = 1; j &lt; m; j++) {
                if (matrix[i][0] ==0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }
        if (row) {
            for (int i = 0; i &lt;m; i++) {
                matrix[0][i] = 0;
            }
        }
        if (col) {
            for (int i = 0; i &lt;n; i++) {
                matrix[i][0] = 0;
            }
        }
 &nbsp;  }
</code></pre>
<h1 id="toc_h1_4">分治</h1>
<h2 id="toc_h2_5"><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank">169. 多数元素</a></h2>
<p><strong>查找数组中元素出现次数超过数组长度的一半的元素。</strong></p>
<p><strong>利用分治算法，因为次数超过一半的元素，在数组分成两部分的时候，该元素也是左或右部分的众数。</strong></p>
<pre><code>public int majorityElement(int[] nums) {
 &nbsp; &nbsp; &nbsp; &nbsp;return majorityElement(nums, 0, nums.length - 1);
 &nbsp;  }

 &nbsp; &nbsp;public int majorityElement(int[] nums, int l, int r){
 &nbsp; &nbsp; &nbsp; &nbsp;if (l == r){
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return nums[l];
 &nbsp; &nbsp; &nbsp;  }
 &nbsp; &nbsp; &nbsp; &nbsp;int mid = (r - l) / 2 + l;
 &nbsp; &nbsp; &nbsp; &nbsp;int left = majorityElement(nums, l, mid);
 &nbsp; &nbsp; &nbsp; &nbsp;int right = majorityElement(nums, mid + 1, r);
 &nbsp; &nbsp; &nbsp; &nbsp;if (left == right){
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return left;
 &nbsp; &nbsp; &nbsp;  }
 &nbsp; &nbsp; &nbsp; &nbsp;return count(nums, l, r, left, right);
 &nbsp;  }
 &nbsp;
 &nbsp; &nbsp;public int count(int[] nums, int l, int j, int left, int right){
 &nbsp; &nbsp; &nbsp; &nbsp;int res1 = 0;
 &nbsp; &nbsp; &nbsp; &nbsp;int res2 = 0;
 &nbsp; &nbsp; &nbsp; &nbsp;for (int i = l; i &lt;= j; i++) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (nums[i] == left){
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;res1 ++;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (nums[i] == right){
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;res2 ++;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }
 &nbsp; &nbsp; &nbsp;  }
 &nbsp; &nbsp; &nbsp; &nbsp;return res1 &gt; res2 ? left : right;
 &nbsp;  }
</code></pre>
<h1 id="toc_h1_6">双指针技巧</h1>
<h2 id="toc_h2_7">快慢指针常用算法</h2>
<h3 id="toc_h3_8">移除重复的元素</h3>
<pre><code>public int removeDuplicates(int[] nums) {
        int left = 0;
        for (int i = 1; i &lt; nums.length; i++) {
            if (nums[i] != nums[left]) {
                nums[++left] = nums[i];
            }
        }
        return left+1;
 &nbsp;  }
</code></pre>
<h3 id="toc_h3_9"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank">80. 删除有序数组中的重复项 II</a></h3>
<pre><code>public int removeDuplicates(int[] nums) {
 &nbsp; &nbsp; &nbsp; &nbsp;if (nums.length &lt;= 2) {
            return nums.length;
        }
        int left = 2;
        for (int i = 2; i &lt; nums.length; i++) {
            if (nums[i] != nums[left-2]) {
                nums[left++] = nums[i];
            }
        }
        return left;
 &nbsp;  }
</code></pre>
<h3 id="toc_h3_10"><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank">283. 移动零</a></h3>
<pre><code>int i = 0;
        for (int j = 0; j &lt; nums.length; j++) {
            if (nums[j] != 0) {
                nums[i++] = nums[j];
            }
        }
        while (i &lt; nums.length) {
            nums[i++] = 0;
        }
</code></pre>
<h3 id="toc_h3_11"><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank">141. 判断环形链表</a></h3>
<pre><code>public boolean hasCycle(ListNode head) {
 &nbsp; &nbsp; &nbsp; if (head == null || head.next == null) {
            return false;
        }
        ListNode n1 = head;
        ListNode n2 = head.next;
        while (n1 != null &amp;&amp; n2 != null &amp;&amp; n2.next != null) {
            if (n1 == n2) {
                return true;
            }
            n1 = n1.next;
            n2 = n2.next.next;
        }
        return false;
 &nbsp;  }
</code></pre>
<h3 id="toc_h3_12"><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank">142. 环形链表 II返回环形的初始节点</a></h3>
<pre><code> &nbsp; &nbsp;public ListNode detectCycle(ListNode head) {
 &nbsp; &nbsp; &nbsp; &nbsp;if (head == null || head.next == null) {
            return null;
        }
        ListNode n1 = head;
        ListNode n2 = head;
        while (n1 != null &amp;&amp; n2 != null &amp;&amp; n2.next != null) {
            n1 = n1.next;
            n2 = n2.next.next;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (n1 == n2) {
                n1 = head;
                while (n1 != n2) {
                    n1 = n1.next;
                    n2 = n2.next;
                }
                return n1;
            }
        }
        return null;
 &nbsp;  }
</code></pre>
<h3 id="toc_h3_13"><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank">876. 返回链表的中间结点</a></h3>
<pre><code>public ListNode middleNode(ListNode head) {
 &nbsp; &nbsp; &nbsp; &nbsp;if (head == null || head.next == null) {
            return head;
        }
        ListNode n2 = head;
        while (n2 != null &amp;&amp; n2.next != null) {
            head = head.next;
            n2 = n2.next.next;
        }
        return head;
 &nbsp;  }
</code></pre>
<h3 id="toc_h3_14">4、寻找链表的倒数第 k 个元素</h3>
<p><strong>我们的思路还是使用快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）：</strong></p>
<pre><code>ListNode slow, fast;
slow = fast = head;
while (k-- &gt; 0) 
 &nbsp; &nbsp;fast = fast.next;

while (fast != null) {
 &nbsp; &nbsp;slow = slow.next;
 &nbsp; &nbsp;fast = fast.next;
}
return slow;
</code></pre>
<h2 id="toc_h2_15">左右指针常用算法</h2>
<h3 id="toc_h3_16"><a href="https://leetcode-cn.com/problems/3sum/" target="_blank">15. 三数之和</a></h3>
<p><strong>首先 使用 左右指针需要先进行排序</strong></p>
<p><strong>三数之和为0，-&gt;  两数之后等于第三个数的相反数 -&gt;双子针，记得排除重复的数</strong></p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int n = nums.length;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Arrays.sort(nums);
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 枚举 a
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int first = 0; first &lt; n; ++first) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 需要和上一次枚举的数不相同
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (first &gt; 0 &amp;&amp; nums[first] == nums[first - 1]) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;continue;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// c 对应的指针初始指向数组的最右端
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int third = n - 1;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int target = -nums[first];
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 枚举 b
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int second = first + 1; second &lt; n; ++second) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 需要和上一次枚举的数不相同
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (second &gt; first + 1 &amp;&amp; nums[second] == nums[second - 1]) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;continue;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 需要保证 b 的指针在 c 的指针的左侧
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--third;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 如果指针重合，随着 b 后续的增加
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (second == third) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (nums[second] + nums[third] == target) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;list.add(nums[first]);
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;list.add(nums[second]);
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;list.add(nums[third]);
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ans.add(list);
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return ans;
 &nbsp; &nbsp; &nbsp;  }
</code></pre>
<h3 id="toc_h3_17"><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank">11. 盛最多水的容器</a></h3>
<pre><code>public int maxArea(int[] height) {
 &nbsp; &nbsp; &nbsp; &nbsp; int left = 0,right = height.length-1;
        int max = 0;
        while (left &lt; right) {
            if (height[left] &gt; height[right]) {
                max = Math.max(max, height[right]*(right-left));
                right--;
            }else {
                max = Math.max(max, height[left]*(right-left));
                left++;
            }
        }
        return max;
 &nbsp;  }
</code></pre>
<h3 id="toc_h3_18"><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank">167. 两数之和 II - 输入有序数组</a></h3>
<pre><code>public int[] twoSum(int[] numbers, int target) {
 &nbsp; &nbsp; &nbsp; &nbsp; int left = 0, right = numbers.length-1;
        while (left &lt; right) {
            if (numbers[left] + numbers[right] == target) {
                break;
            }else if (numbers[left] + numbers[right] &gt; target) {
                right--;
            }else if (numbers[left] + numbers[right] &lt; target) {
                left++;
            }
        }
        return new int[] {left+1, right+1};
 &nbsp;  }
</code></pre>
<h3 id="toc_h3_19"><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank">75. 颜色分类</a></h3>
<pre><code>public void sortColors(int[] nums) {
 &nbsp; &nbsp; &nbsp; &nbsp;if (nums.length &lt;= 1) {
            return;
        }
        int left = 0, right = nums.length-1;
        for (int i = 0; i &lt;= right; i++) {
            if (nums[i] == 0) {
                swap(nums, left++, i);
            }else if (nums[i] == 2) {
                swap(nums, right--, i--);
            }
        }
 &nbsp;  }
</code></pre>
<h3 id="toc_h3_20"><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank">27. 移除元素</a></h3>
<pre><code>public int removeElement(int[] nums, int val) {
 &nbsp; &nbsp; &nbsp; &nbsp;int i = 0;
         for (int j = 0; j &lt; nums.length; j++) {
            if (val != nums[j]) {
                nums[i] = nums[j];
                i++;
            }
        }
        return i;
 &nbsp;  }
</code></pre>
<h3 id="toc_h3_21">二分查找</h3>
<pre><code>/**
	 * 查找元素，存在返回索引，不存在返回-1
	 * @param arr
	 * @param target
	 * @return
	 */
	public static int binarySearch(int[] arr, int target) {
		int left = 0,right = arr.length-1; //注意
		while (left &lt;= right) { //注意
			//这样写是为了防止溢出
			int mid = right - (right - left)/2;
			if (arr[mid] &gt; target) {
				right = mid-1;
			}else if(arr[mid] &lt; target) {
				left = mid +1;
			}else {
				return mid;
			}
		}
		return -1;
	}
</code></pre>
<h4 id="toc_h4_22">框架：</h4>
<pre><code>int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = (right + left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] &lt; target) {
            left = ...
        } else if (nums[mid] &gt; target) {
            right = ...
        }
    }
    return ...;
}
</code></pre>
<h4 id="toc_h4_23">查找元素</h4>
<p><strong>存在返回索引，不存在返回-1</strong></p>
<p><strong>注意：</strong></p>
<p><em>1</em>. 为什么 while 循环的条件中是 &lt;=，而不是 &lt; ？</p>
<p><strong>答：因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。</strong></p>
<p><strong>while(left &lt;= right)的终止条件是 left == right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见****这时候搜索区间为空</strong>，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p>
<p>**while(left &lt; right)的终止条件是 left == right，写成区间的形式就是 [right, right]，或者带个具体的数字进去 [2, 2]，**<strong>这时候搜索区间非空</strong>，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就可能出现错误。</p>
<p><strong>当然，如果你非要用 while(left &lt; right) 也可以，我们已经知道了出错的原因，就打个补丁好了：</strong></p>
<pre><code>//...
while(left &lt; right) {
    // ...
}
return nums[left] == target ? left : -1;
</code></pre>
<pre><code>/**
	 * 查找元素，存在返回索引，不存在返回-1
	 * @param arr
	 * @param target
	 * @return
	 */
	public static int binarySearch(int[] arr, int target) {
		int left = 0,right = arr.length-1; //注意
		while (left &lt;= right) { //注意
			//这样写是为了防止溢出
			int mid = right - (right - left)/2;
			if (arr[mid] &gt; target) {
				right = mid-1;
			}else if(arr[mid] &lt; target) {
				left = mid +1;
			}else {
				return mid;
			}
		}
		return -1;
	}
</code></pre>
<p><em>3</em>. 此算法有什么缺陷？</p>
<p><strong>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。</strong></p>
<p><strong>比如说给你有序数组 nums = [1,2,2,2,3]，target = 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是无法处理的。</strong></p>
<p><strong>这样的需求很常见。你也许会说，找到一个 target 索引，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。</strong></p>
<p><strong>我们后续的算法就来讨论这两种二分查找的算法。</strong></p>
<h5 id="toc_h5_24">寻找左侧边界的二分搜索</h5>
<pre><code>/**
	 * 查找元素，存在返回最左侧的索引，不存在返回-1
	 * @param arr
	 * @param target
	 * @return
	 */
	public static int binarySearch(int[] nums, int target) {
		if (nums.length == 0) return -1;
	    int left = 0;
	    int right = nums.length; // 注意
	    while (left &lt; right) { // 注意
	        int mid = (left + right)/2; 
	        //这两个值不一定相同。
	        System.out.println((right + (left - right)/2) == ((left + right)/2));
	        if (nums[mid] == target) {
	            right = mid;
	        } else if (nums[mid] &lt; target) {
	            left = mid + 1;
	        } else if (nums[mid] &gt; target) {
	            right = mid; // 注意
	        }
	    }
	    // target 比所有数都大
	    if (left == nums.length) return -1;
	    // 类似之前算法的处理方式
	    return nums[left] == target ? left : -1;
	}
</code></pre>
<h5 id="toc_h5_25">寻找右侧边界的二分查找</h5>
<pre><code>/**
	 * 查找元素，存在返回最右侧的索引，不存在返回-1
	 * @param arr
	 * @param target
	 * @return
	 */
	public static int binarySearch(int[] nums, int target) {
		if (nums.length == 0) return -1;
	    int left = 0;
	    int right = nums.length; // 注意
	    while (left &lt; right) { // 注意
	        int mid = (left + right)/2; 
	        //这两个值不一定相同。
	        System.out.println((right + (left - right)/2) == ((left + right)/2));
	        if (nums[mid] == target) {
	            left = mid+1; //注意
	        } else if (nums[mid] &lt; target) {
	        	 left = mid + 1;
	        } else if (nums[mid] &gt; target) {
	        	 right = mid; // 注意
	        }
	    }
	    if (left == 0) return -1;
	    return nums[left-1] == target ? (left-1) : -1;
	}
</code></pre>
<h4 id="toc_h4_26">总结</h4>
<p><strong>梳理一下这些细节差异的因果逻辑：</strong></p>
<p><strong>第一个，最基本的二分查找算法：</strong></p>
<pre><code>因为我们初始化&nbsp;right&nbsp;=&nbsp;nums.length&nbsp;-&nbsp;1
所以决定了我们的「搜索区间」是&nbsp;[left,&nbsp;right]
所以决定了&nbsp;while&nbsp;(left&nbsp;&lt;=&nbsp;right)
同时也决定了&nbsp;left&nbsp;=&nbsp;mid+1&nbsp;和&nbsp;right&nbsp;=&nbsp;mid-1

因为我们只需找到一个&nbsp;target&nbsp;的索引即可
所以当&nbsp;nums[mid]&nbsp;==&nbsp;target&nbsp;时可以立即返回
</code></pre>
<p><strong>第二个，寻找左侧边界的二分查找：</strong></p>
<pre><code>因为我们初始化&nbsp;right&nbsp;=&nbsp;nums.length
所以决定了我们的「搜索区间」是&nbsp;[left,&nbsp;right)
所以决定了&nbsp;while&nbsp;(left&nbsp;&lt;&nbsp;right)
同时也决定了&nbsp;left&nbsp;=&nbsp;mid+1&nbsp;和&nbsp;right&nbsp;=&nbsp;mid

因为我们需找到&nbsp;target&nbsp;的最左侧索引
所以当&nbsp;nums[mid]&nbsp;==&nbsp;target&nbsp;时不要立即返回
而要收紧右侧边界以锁定左侧边界
</code></pre>
<p><strong>第三个，寻找右侧边界的二分查找：</strong></p>
<pre><code>因为我们初始化&nbsp;right&nbsp;=&nbsp;nums.length
所以决定了我们的「搜索区间」是&nbsp;[left,&nbsp;right)
所以决定了&nbsp;while&nbsp;(left&nbsp;&lt;&nbsp;right)
同时也决定了&nbsp;left&nbsp;=&nbsp;mid+1&nbsp;和&nbsp;right&nbsp;=&nbsp;mid

因为我们需找到&nbsp;target&nbsp;的最右侧索引
所以当&nbsp;nums[mid]&nbsp;==&nbsp;target&nbsp;时不要立即返回
而要收紧左侧边界以锁定右侧边界

又因为收紧左侧边界时必须&nbsp;left&nbsp;=&nbsp;mid&nbsp;+&nbsp;1
所以最后无论返回&nbsp;left&nbsp;还是&nbsp;right，必须减一
</code></pre>
<p><em>1.</em> 分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。</p>
<p><em>2.</em> 注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。</p>
<p><em>3.</em> 如需要搜索左右边界，只要在 nums[mid] == target 时做修改即可。搜索右侧时需要减一。</p>
<h4 id="toc_h4_27">例题</h4>
<h5 id="toc_h5_28"><a href="https://leetcode-cn.com/problems/koko-eating-bananas/" target="_blank">875. 爱吃香蕉的珂珂</a></h5>
<pre><code>public int minEatingSpeed(int[] piles, int h) {
       int right = piles[0];
		for (int i = 1; i &lt; piles.length; i++) {
			right = Math.max(right, piles[i]);
		}
		int left = 1;
		int time;
		int mid = 0;
        right++;
		while (left &lt; right) {
			mid = (right + left) /2;
			time = 0;
			for (int i = 0; i &lt; piles.length; i++) {
				time += piles[i] / mid + (piles[i] % mid == 0 ? 0 : 1);
			}
			if (time &lt;= h) {
				right = mid;
			}else{
				left = mid + 1;
			}
		}
		return left;
    }
</code></pre>
<h5 id="toc_h5_29"><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/" target="_blank">1011. 在 D 天内送达包裹的能力</a></h5>
<pre><code>class Solution {
    // 寻找左侧边界的二分查找
	public int shipWithinDays(int[] weights, int D) {
	    // 载重可能的最小值
	    int left = getMax(weights);
	    // 载重可能的最大值 + 1
	    int right = getSum(weights) + 1;
	    while (left &lt; right) {
	        int mid = left + (right - left) / 2;
	        if (canFinish(weights, D, mid)) {
	            right = mid;
	        } else {
	            left = mid + 1;
	        }
	    }
	    return left;
	}

	// 如果载重为 cap，是否能在 D 天内运完货物？
	public boolean canFinish(int[] w, int D, int cap) {
	    int i = 0;
	    for (int day = 0; day &lt; D; day++) {
	        int maxCap = cap;
	        while ((maxCap -= w[i]) &gt;= 0) {
	            i++;
	            if (i == w.length)
	                return true;
	        }
	    }
	    return false;
	}

	public int getSum(int[] nums) {
		int sum = 0;
		for (int j2 = 0; j2 &lt; nums.length; j2++) {
			sum += nums[j2];
		}
		return sum;
	}
	public int getMax(int[] nums) {
		return nums[nums.length -1];
	}

}
</code></pre>
<h5 id="toc_h5_30"><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank">难153. 寻找旋转排序数组中的最小值</a></h5>
<pre><code>public int findMin(int[] nums) {
        int left = 0, right = nums.length -1;
		while (left &lt; right) {
			int mid = (left + right)/2;
			if (nums[mid] &lt; nums[right]) {
                right = mid;
            } else {
                left = mid + 1;
            }
		}
		return nums[left];
    }
</code></pre>
<h5 id="toc_h5_31"><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank">上一题的进阶154. 寻找旋转排序数组中的最小值 II</a></h5>
<pre><code>public int findMin(int[] nums) {
        int left = 0, right = nums.length-1;
		while (left &lt; right) {
			int mid = (left +right)/2;
			if (nums[mid] &lt; nums[right]) {
				right = mid;
			}else if (nums[mid] &gt; nums[right]) {
				left = mid +1;
			}else if (nums[mid] == nums[right]) {
				right--;
			}
		}
		return nums[left];
    }
</code></pre>
<h3 id="toc_h3_32">两数之和（给定的数组是有序的）</h3>
<pre><code>public int[] twoSum(int[] nums, int target) {
        int left = 0,right = nums.length-1;
        while (left &lt;= right) {
        	int sum = nums[left] + nums[right];
			if (sum == target) {
				return new int[] {left,right};
			}else if (sum &gt; target) {
				right = right -1;
			}else if (sum &lt; target) {
				left = left + 1;
			}
		}
        return null;
	 }
</code></pre>
<h3 id="toc_h3_33">反转数组</h3>
<pre><code>void reverse(int[] nums) {
    int left = 0;
    int right = nums.length - 1;
    while (left &lt; right) {
        // swap(nums[left], nums[right])
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
        left++; right--;
    }
}
</code></pre>
<h2 id="toc_h2_34">滑动窗口常见算法</h2>
<p><img src="https://b3logfile.com/file/2021/04/image-14302fc3.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt=""></p>
<p><strong>做题明确四个问题：</strong></p>
<blockquote>
<p>**1、**当移动<code>right</code>扩大窗口，即加入字符时，应该更新哪些数据？</p>
<p>**2、**什么条件下，窗口应该暂停扩大，开始移动<code>left</code>缩小窗口？</p>
<p>**3、**当移动<code>left</code>缩小窗口，即移出字符时，应该更新哪些数据？</p>
<p>**4、**我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</p>
</blockquote>
<p><strong>一套滑动窗口算法的代码框架，在哪里做输出 debug 都写好了，以后遇到相关的问题，就默写出来如下框架然后改三个地方就行，还不会出边界问题</strong>：</p>
<pre><code>/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map&lt;char, int&gt; need, window;
    for (char c : t) need[c]++;

    int left = 0, right = 0;
    int valid = 0; 
    while (right &lt; s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/

        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
</code></pre>
<h3 id="toc_h3_35"><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank">76. 最小覆盖子串</a></h3>
<pre><code>class Solution {
    public static String minWindow(String s, String t) {
		Map&lt;Character, Integer&gt; need = new HashMap&lt;&gt;();
		//窗口的区间是[left,right)
		Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;();
		for (int i = 0; i &lt; t.length(); i++) {
			char c = t.charAt(i);
			need.put(c, need.getOrDefault(c, 0)+1);
			window.put(c, 0);
		}
	    //指针
		int left = 0, right = 0;
		int len = Integer.MAX_VALUE;
		int start = 0;
		int end = 0;
		while (right &lt; s.length()) {
			char add = s.charAt(right);
			right ++;
			if (need.containsKey(add)) {
				window.put(add, window.getOrDefault(add, 0)+1);
			}
			//判断当前窗口[left,right)是否已经存了所有的值 

			//对left操作
			while (judgeWindoe(window, need)) {
				if (right - left &lt; len) {
					start = left;
					end = right;
                    len = right - left;
				}
				char remove = s.charAt(left);
				left ++;
				if (window.containsKey(remove)) {
					window.put(remove, window.get(remove) -1);
				}
			}
		}
		return len == Integer.MAX_VALUE ? "" : s.substring(start, end);
	 }
	 
	 public static boolean judgeWindoe(Map&lt;Character, Integer&gt; window, Map&lt;Character, Integer&gt; need) {
		 Set&lt;Character&gt; setKey = need.keySet();
		 for (Character key : setKey) {
			if (need.get(key) &gt; window.get(key)) {
				return false;
			}
		}
		 return true;
	 }
}
</code></pre>
<h3 id="toc_h3_36"><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank">567. 字符串的排列</a></h3>
<pre><code>public boolean checkInclusion(String p, String s) {
        Map&lt;Character, Integer&gt; needMap = new HashMap&lt;&gt;();
		Map&lt;Character, Integer&gt; windowMap = new HashMap&lt;&gt;();
		for (int i = 0; i &lt; p.length(); i++) {
			needMap.put(p.charAt(i), needMap.getOrDefault(p.charAt(i), 0)+1);
		}
		int left = 0,right = 0;
		int valid = 0;
		while (right &lt; s.length()) {
			char add = s.charAt(right);
			right++;
			if (needMap.containsKey(add)) {
				windowMap.put(add, windowMap.getOrDefault(add, 0)+1);
				if (windowMap.get(add).equals(needMap.get(add))) {
					valid++;
				}
			}
			if (right - left == p.length()) {
				if (valid == needMap.size()) {
					return true;
				}
				char remove = s.charAt(left);
				left ++;
				if (needMap.containsKey(remove)) {
					if (windowMap.get(remove).equals(needMap.get(remove))) {
						valid--;
					}
					windowMap.put(remove, windowMap.get(remove)-1);
				}
			}
		}
		return false;
    }
</code></pre>
<h3 id="toc_h3_37"><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank">438. 找到字符串中所有字母异位词</a></h3>
<pre><code>public List&lt;Integer&gt; findAnagrams(String s, String p) {
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
		Map&lt;Character, Integer&gt; needMap = new HashMap&lt;&gt;();
		Map&lt;Character, Integer&gt; windowMap = new HashMap&lt;&gt;();
		for (int i = 0; i &lt; p.length(); i++) {
			needMap.put(p.charAt(i), needMap.getOrDefault(p.charAt(i), 0)+1);
		}
		int left = 0,right = 0;
		int valid = 0;
		while (right &lt; s.length()) {
			char add = s.charAt(right);
			right++;
			if (needMap.containsKey(add)) {
				windowMap.put(add, windowMap.getOrDefault(add, 0)+1);
				if (windowMap.get(add).equals(needMap.get(add))) {
					valid++;
				}
			}
			if (right - left == p.length()) {
				if (valid == needMap.size()) {
					list.add(left);
				}
				char remove = s.charAt(left);
				left ++;
				if (needMap.containsKey(remove)) {
					if (windowMap.get(remove).equals(needMap.get(remove))) {
						valid--;
					}
					windowMap.put(remove, windowMap.get(remove)-1);
				}
			}
		}
		return list;
    }
</code></pre>
<h3 id="toc_h3_38"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank">3. 无重复字符的最长子串</a></h3>
<pre><code>public int lengthOfLongestSubstring(String s) {
        Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;();
	    int left = 0, right = 0;
	    int res = 0; // 记录结果
	    while (right &lt; s.length()) {
	        char c = s.charAt(right);
	        right++;
	        // 进行窗口内数据的一系列更新
	        window.put(c, window.getOrDefault(c, 0)+1);
	        // 判断左侧窗口是否要收缩
	        while (window.get(c) &gt; 1) {
	            char d = s.charAt(left);
	            left++;
	            // 进行窗口内数据的一系列更新
	            window.put(d, window.get(d)-1);
	        }
	        // 在这里更新答案
	        res = Math.max(res, right - left);
	    }
	    return res;  
    }
</code></pre>
<h3 id="toc_h3_39"><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank">209. 长度最小的子数组</a></h3>
<pre><code>public int minSubArrayLen(int target, int[] nums) {
        int sum = 0;
		int left = 0;
		int right = 0;
		int min = nums.length+1;
		while (right &lt; nums.length) {
			sum += nums[right];

			while (sum &gt;= target) {
				min = Math.min(min, right-left+1);
				sum = sum - nums[left];
				left++;
			}
			right++;
		}
		return min == nums.length+1 ? 0 : min;
    }
</code></pre>
<h1 id="toc_h1_40">给我 O(1) 时间，我能查找/删除数组中的任意元素</h1>
<p><strong>可以做到！对数组尾部进行插入和删除操作不会涉及数据搬移，时间复杂度是 O(1)。</strong></p>
<p><strong>所以，如果我们想在 O(1) 的时间删除数组中的某一个元素<code>val</code>，可以先把这个元素交换到数组的尾部，然后再<code>pop</code>掉</strong>。</p>
<h1 id="toc_h1_41">数组去重</h1>
<h2 id="toc_h2_42"><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank">316. 去除重复字母</a></h2>
<blockquote>
<p><strong>利用栈来解决。</strong></p>
<p><strong>栈：后入先出。</strong></p>
</blockquote>
<pre><code>public String removeDuplicateLetters(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
		int[] counts = new int[255];
		for (int i = 0; i &lt; s.length(); i++) {
			counts[s.charAt(i)] = i;
		}
		for (int i = 0; i &lt; s.length(); i++) {
			char c = s.charAt(i);
			if (!stack.contains(c)) {
				while (!stack.isEmpty() &amp;&amp; c &lt; stack.peek() &amp;&amp; counts[stack.peek()] &gt; i) {
					stack.pop();
				}
				stack.push(c);
			}
		}

		String string = "";
		while (!stack.empty()) {
			string = stack.pop() + string;
		}
		return string;
    }
</code></pre>
<p><strong>我们顺序遍历字符串</strong><code>s</code>，通过「栈」这种顺序结构的 push/pop 操作记录结果字符串，保证了字符出现的顺序和<code>s</code>中出现的顺序一致。</p>
<p><strong>这里也可以想到为什么要用「栈」这种数据结构，因为先进后出的结构允许我们立即操作刚插入的字符，如果用「队列」的话肯定是做不到的。</strong></p>
<p><strong>要求三、我们用类似单调栈的思路，配合计数器</strong><code>count</code>不断 pop 掉不符合最小字典序的字符，保证了最终得到的结果字典序最小。</p>
<p><strong>当然，由于栈的结构特点，我们最后需要把栈中元素取出后再反转一次才是最终结果。</strong></p>
<h2 id="toc_h2_43"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank">83. 删除排序链表中的重复元素</a></h2>
<pre><code>public ListNode deleteDuplicates(ListNode head) {
        if (head == null) return null;
		    ListNode slow = head, fast = head;
		    while (fast != null) {
		        if (fast.val != slow.val) {
		            // nums[slow] = nums[fast];
		            slow.next = fast;
		            // slow++;
		            slow = slow.next;
		        }
		        // fast++
		        fast = fast.next;
		    }
		    // 断开与后面重复元素的连接
		    slow.next = null;
		    return head;
    }
</code></pre>
<h2 id="toc_h2_44"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank">26. 删除有序数组中的重复项</a></h2>
<pre><code> public int removeDuplicates(int[] nums) {
        if(nums.length &lt; 2) {
			return nums.length;
		}
		int i = 0;
		for (int j = 1; j &lt; nums.length; j++) {
			if(nums[i] != nums[j]) {
				i++;
				nums[i] = nums[j];
			}
		}
		return i+1;
    }
</code></pre>
<h2 id="toc_h2_45"><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank">27. 移除元素</a></h2>
<pre><code>public int removeElement(int[] nums, int val) {
        int i = 0;
		 for (int j = 0; j &lt; nums.length; j++) {
			if (val != nums[j]) {
				nums[i] = nums[j];
				i++;
			}
		}
		return i;
    }
</code></pre>
<h2 id="toc_h2_46"><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank">283. 移动零</a></h2>
<pre><code>public void moveZeroes(int[] nums) {
        int i = 0;
		for (int j = 0; j &lt; nums.length; j++) {
			if (nums[j] != 0) {
				nums[i++] = nums[j];
			}
		}
		while (i &lt; nums.length) {
			nums[i++] = 0;
		}
    }
</code></pre>
<h1 id="toc_h1_47">小而美的算法技巧</h1>
<h2 id="toc_h2_48">前缀和数组</h2>
<p><strong>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和</strong>。</p>
<blockquote>
<p><strong>要计算数组中子数组的和为k的有多少个？</strong></p>
<p><strong>普通解法：把所有的子数组列出来，在判断。</strong></p>
<p><strong>利用前缀和数组：新建立起来一个数组prefix，记录0-i的和，包括本身。即prifix[i] = nums[0-i] 的和。找出一个子数组的和就是prifix[i] - prifix[i-1];</strong></p>
</blockquote>
<h3 id="toc_h3_49"><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank">560. 和为K的子数组</a></h3>
<p><strong>解法：</strong></p>
<pre><code>public int subarraySum(int[] nums, int k) {
        int[] prefix = new int[nums.length+1];
        //得到前缀和数组
        for (int i = 0; i &lt; nums.length; i++) {
			prefix[i+1] = prefix[i] + nums[i];
		}
        int sum = 0;
		for (int i = 1; i &lt; prefix.length; i++) {
			for (int j = 0; j &lt; i; j++) {
				if (prefix[i] - prefix[j] == k) {
					sum++;
				}
			}
		}
        return sum;
    }
</code></pre>
<p><strong>利用哈希表优化算法。（和求一个数组中等于target的两个元素的索引的题类似）</strong></p>
<pre><code>public int subarraySum(int[] nums, int k) {
        int preSum = 0;
        int count = 0;
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        map.put(0,1);
		for (int i = 0; i &lt; nums.length; i++) {
			preSum += nums[i];
			if (map.containsKey(preSum-k)) {
				count+=map.get(preSum-k);
			}
			map.put(preSum, map.getOrDefault(preSum, 0) + 1);
		}
        return count;
    }
</code></pre>
<h2 id="toc_h2_50">差分数组</h2>
<p><strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</strong>。</p>
<p><strong>构造差分数组：</strong></p>
<pre><code>//构造差分数组 原：2,3,5,1,2,6
        int[] diff = new int[nums.length];
        diff[0] = nums[0];
        for (int i = 1; i &lt; diff.length; i++) {
		diff[i] = nums[i] - nums[i-1];
	}
	System.out.println(Arrays.toString(diff));//[2, 1, 2, -4, 1, 4]
</code></pre>
<p><strong>还原差分数组：</strong></p>
<pre><code>//差分数组还原
	int[] res = new int[diff.length];
	res[0] = diff[0];
	for (int i = 1; i &lt; diff.length; i++) {
		res[i] = diff[i]+res[i-1];
	}
	System.out.println(Arrays.toString(res));//[2, 3, 5, 1, 2, 6]
</code></pre>
<p><strong>差分数组特性：</strong></p>
<blockquote>
<p><strong>回想<code>diff</code>数组反推<code>nums</code>数组的过程，<code>diff[i] += 3</code>意味着给<code>nums[i..]</code>所有的元素都加了 3，然后<code>diff[j+1] -= 3</code>又意味着对于<code>nums[j+1..]</code>所有元素再减 3，那综合起来，是不是就是对<code>nums[i..j]</code>中的所有元素都加 3 了</strong>？</p>
</blockquote>
<p><strong>示例：</strong></p>
<h3 id="toc_h3_51"><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/" target="_blank">1109. 航班预订统计</a></h3>
<pre><code>public static int[] corpFlightBookings(int[][] bookings, int n) {
		//差分数组
		int[] diff = new int[n];
		for (int i = 0; i &lt; bookings.length; i++) {
			//因为first是从1开始的所以减一
			int first = bookings[i][0]-1;
			int end = bookings[i][1];
			int seats = bookings[i][2];
			diff[first] += seats;
			//如果增加到最后一位了，就不需要减操作了
			if (end &lt; diff.length) {
				diff[end] -= seats;
			}
		}
		int[] res = new int[n];
		res[0] = diff[0];
		//还原数组
		for (int i = 1; i &lt; res.length; i++) {
			res[i] = res[i-1]+diff[i];
		}
		return res;
    }

</code></pre>
<h2 id="toc_h2_52">快排亲兄弟：快速选择算法详解</h2>
<h3 id="toc_h3_53"><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank">215. 数组中的第K个最大元素</a></h3>
<blockquote>
<p><strong>第k个最大的元素就是排好序之后索引为len-k的的值。寻找他，可以利用快速排序的思维，只要寻找到索引就可以，不需要把整个数组排序。</strong></p>
</blockquote>
<pre><code>class Solution {
    Random random = new Random();

    public int findKthLargest(int[] nums, int k) {
        return quickSelect(nums, 0, nums.length - 1, nums.length - k);
    }

    public int quickSelect(int[] a, int l, int r, int index) {
        int q = randomPartition(a, l, r);
        if (q == index) {
            return a[q];
        } else {
            return q &lt; index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);
        }
    }

    public int randomPartition(int[] a, int l, int r) {
        int i = random.nextInt(r - l + 1) + l;
        swap(a, i, r);
        return partition(a, l, r);
    }

    public int partition(int[] a, int l, int r) {
        int x = a[r], i = l - 1;
        for (int j = l; j &lt; r; ++j) {
            if (a[j] &lt;= x) {
                swap(a, ++i, j);
            }
        }
        swap(a, i + 1, r);
        return i + 1;
    }

    public void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}

</code></pre>
<p><strong>使用优先级队列实现：实际写算法的时候推荐使用。</strong></p>
<pre><code>int findKthLargest(int[] nums, int k) {
    // 小顶堆，堆顶是最小元素
    PriorityQueue&lt;Integer&gt; 
        pq = new PriorityQueue&lt;&gt;();
    for (int e : nums) {
        // 每个元素都要过一遍二叉堆
        pq.offer(e);
        // 堆中元素多于 k 个时，删除堆顶元素
        if (pq.size() &gt; k) {
            pq.poll();
        }
    }
    // pq 中剩下的是 nums 中 k 个最大元素，
    // 堆顶是最小的那个，即第 k 个最大元素
    return pq.peek();
}
</code></pre>
<h2 id="toc_h2_54">分治算法详解：表达式的不同优先级</h2>
<p><strong>最典型的分治算法就是归并排序了，核心逻辑如下：</strong></p>
<pre><code>void sort(int[] nums, int lo, int hi) {
    int mid = (lo + hi) / 2;
    /****** 分 ******/
    // 对数组的两部分分别排序
    sort(nums, lo, mid);
    sort(nums, mid + 1, hi);
    /****** 治 ******/
    // 合并两个排好序的子数组
    merge(nums, lo, mid, hi);
}
</code></pre>
<h3 id="toc_h3_55"><a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/" target="_blank">241. 为运算表达式设计优先级</a></h3>
<p><strong>解决本题的关键有两点：</strong></p>
<p><strong>1、不要思考整体，而是把目光聚焦局部，只看一个运算符</strong>。</p>
<p><strong>解决递归相关的算法问题，就是一个化整为零的过程，你必须瞄准一个小的突破口，然后把问题拆解，大而化小，利用递归函数来解决。</strong></p>
<p><strong>2、明确递归函数的定义是什么，相信并且利用好函数的定义</strong>。</p>
<p><strong>因为递归函数要自己调用自己，你必须搞清楚函数到底能干嘛，才能正确进行递归调用。</strong></p>
<blockquote>
<p><strong>相信定义：</strong></p>
<p><strong>该题：求一个式子的在不同优先级下的计算结果，就可是以每个运算符分隔开来的两个式子的和，由此递归求出结果。</strong></p>
</blockquote>
<pre><code>	//备忘录
	Map&lt;String, List&lt;Integer&gt;&gt; memo = new HashMap&lt;&gt;();
	//返回一个式子的在不同优先级下的计算结果
	public List&lt;Integer&gt; diffWaysToCompute(String expression) {
		 // 避免重复计算
	    if (memo.containsKey(expression)) {
	        return memo.get(expression);
	    }
		List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
		for (int i = 0; i &lt; expression.length(); i++) {
			char ch = expression.charAt(i);
			if (ch == '-' || ch == '+' || ch == '*') {
		/****** 分 ******/
            // 以运算符为中心，分割成两个字符串，分别递归计算
				List&lt;Integer&gt; left = diffWaysToCompute(expression.substring(0,i));
				List&lt;Integer&gt; right = diffWaysToCompute(expression.substring(i+1));
		 /****** 治 ******/
            // 通过子问题的结果，合成原问题的结果
				for (Integer r : right) {
					for (Integer l : left) {
						if (ch == '-') {
							res.add(l-r);
						}
						if (ch == '*') {
							res.add(l*r);
						}
						if (ch == '+') {
							res.add(l+r);
						}
					}
				}
			}

		}
  // 如果 res 为空，说明算式是一个数字，没有运算符
		if (res.isEmpty()) {
	        res.add(Integer.parseInt(expression));
	    }
		memo.put(expression,res);
		return res;
    }
</code></pre>
<p><strong>解决上述算法题利用了分治思想，以每个运算符作为分割点，把复杂问题分解成小的子问题，递归求解子问题，然后再通过子问题的结果计算出原问题的结果。把大规模的问题分解成小规模的问题递归求解</strong></p>
<h2 id="toc_h2_56">特殊的排序算法</h2>
<h3 id="toc_h3_57"><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank">剑指 Offer 45. 把数组排成最小的数</a></h3>
<pre><code>public String minNumber(int[] nums) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        for (int num : nums) {
            list.add(String.valueOf(num));
        }
        list.sort((o1, o2) -&gt; (o1 + o2).compareTo(o2 + o1));
        return String.join("", list);
    }
</code></pre>
                                        <div class="marginTop12">
                                            <hr>

标题：算法：数组<br>
作者：<a href="https://gyyspace.github.io" target="_blank">function001</a><br>
地址：<a href="https://gyyspace.github.io/articles/2024/07/21/1721546193766.html" target="_blank">https://gyyspace.github.io/articles/2024/07/21/1721546193766.html</a><br>

<!-- 签名档内可使用 HTML、JavaScript -->
<br>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="margin25">
                                <a rel="nofollow" href="https://gyyspace.github.io/articles/2024/07/21/1721546193766.html" class="left">
                                    <span class="left article-browserIcon" title="浏览"></span>
                                    <span class="count"><span data-uvstaturl="https://gyyspace.github.io/articles/2024/07/21/1721546193766.html">0</span></span>
                                </a>
                                <div class="left">
                                    <span class="tagsIcon" title="标签"></span>
                                    <span class="count">
                                        <a rel="tag" href="https://gyyspace.github.io/tags/%E7%AE%97%E6%B3%95">
                                            算法</a>,
                                    </span>
                                    <span class="count">
                                        <a rel="tag" href="https://gyyspace.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">
                                            数据结构</a>
                                    </span>
                                </div>
                                <a rel="nofollow" href="https://gyyspace.github.io/articles/2024/07/21/1721546193766.html#b3logsolocomments" class="left">
                                    <span class="left articles-commentIcon" title="评论"></span>
                                    <span class="count" data-uvstatcmt="1721546193766">0</span>
                                </a>
                                <div class="right">
                                    <a rel="nofollow" href="#b3logsolocomments" class="right">
                                        回复»
                                    </a>
                                </div>
                                <div class="clear"></div>
                            </div>

                            <div class="margin25">
                                <div class="right">
                                    <a href="https://gyyspace.github.io/articles/2024/07/21/1721546762645.html">新一篇：并发编程：进程、线程</a>
                                </div>
                                <div class="clear"></div>
                                <div class="right">
                                    <a href="https://gyyspace.github.io/articles/2024/07/21/1721546109578.html">旧一篇：算法：数学知识</a>
                                </div>
                                <div class="clear"></div>
                            </div>
                            <div id="relevantArticles" class="article-relative"></div>
                            <div id="randomArticles" class="article-relative"></div>
                            <div id="externalRelevantArticles" class="article-relative"></div>
                        </div>
                            <div id="gitalk-container" class="comments"
                                 style="padding-top: 15px"></div>
                            <div id="b3logsolocomments"></div>
                            <div id="vcomment"
                                 class="comments"
                                 style="padding-top: 15px"
                                 data-name="function001" data-postId="1721546193766"></div>
                    </div>
                    <div class="right">
<div id="sideNavi" class="side-navi">
    <div class="rings"></div>
    <div class="null"></div>
    <div class="item">
        <div class="antefatto">
            <h4>公告</h4>
        </div>
        <div class="marginLeft12 marginTop12">
            Open Source, Open Mind, <br/>Open Sight, Open Future!

<!-- 公告栏可使用 HTML、JavaScript，比如可以在此加入第三方统计 js -->
            <div class="marginTop12">
            </div>
        </div>
    </div>
    <div class="line"></div>

        <div class="item navi-comments">
            <div class="ads">
                <h4>目录</h4>
            </div>
<ul class="article__toc">
        <li class="toc__h1">
            <a href="#toc_h1_0">数组相关题目</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_1">56. 合并区间</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_2">435. 无重叠区间</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_3">面试题 01.08. 零矩阵</a>
        </li>
        <li class="toc__h1">
            <a href="#toc_h1_4">分治</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_5">169. 多数元素</a>
        </li>
        <li class="toc__h1">
            <a href="#toc_h1_6">双指针技巧</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_7">快慢指针常用算法</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_8">移除重复的元素</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_9">80. 删除有序数组中的重复项 II</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_10">283. 移动零</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_11">141. 判断环形链表</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_12">142. 环形链表 II返回环形的初始节点</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_13">876. 返回链表的中间结点</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_14">4、寻找链表的倒数第 k 个元素</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_15">左右指针常用算法</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_16">15. 三数之和</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_17">11. 盛最多水的容器</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_18">167. 两数之和 II - 输入有序数组</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_19">75. 颜色分类</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_20">27. 移除元素</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_21">二分查找</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_22">框架：</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_23">查找元素</a>
        </li>
        <li class="toc__h5">
            <a href="#toc_h5_24">寻找左侧边界的二分搜索</a>
        </li>
        <li class="toc__h5">
            <a href="#toc_h5_25">寻找右侧边界的二分查找</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_26">总结</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_27">例题</a>
        </li>
        <li class="toc__h5">
            <a href="#toc_h5_28">875. 爱吃香蕉的珂珂</a>
        </li>
        <li class="toc__h5">
            <a href="#toc_h5_29">1011. 在 D 天内送达包裹的能力</a>
        </li>
        <li class="toc__h5">
            <a href="#toc_h5_30">难153. 寻找旋转排序数组中的最小值</a>
        </li>
        <li class="toc__h5">
            <a href="#toc_h5_31">上一题的进阶154. 寻找旋转排序数组中的最小值 II</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_32">两数之和（给定的数组是有序的）</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_33">反转数组</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_34">滑动窗口常见算法</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_35">76. 最小覆盖子串</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_36">567. 字符串的排列</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_37">438. 找到字符串中所有字母异位词</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_38">3. 无重复字符的最长子串</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_39">209. 长度最小的子数组</a>
        </li>
        <li class="toc__h1">
            <a href="#toc_h1_40">给我 O(1) 时间，我能查找/删除数组中的任意元素</a>
        </li>
        <li class="toc__h1">
            <a href="#toc_h1_41">数组去重</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_42">316. 去除重复字母</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_43">83. 删除排序链表中的重复元素</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_44">26. 删除有序数组中的重复项</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_45">27. 移除元素</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_46">283. 移动零</a>
        </li>
        <li class="toc__h1">
            <a href="#toc_h1_47">小而美的算法技巧</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_48">前缀和数组</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_49">560. 和为K的子数组</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_50">差分数组</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_51">1109. 航班预订统计</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_52">快排亲兄弟：快速选择算法详解</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_53">215. 数组中的第K个最大元素</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_54">分治算法详解：表达式的不同优先级</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_55">241. 为运算表达式设计优先级</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_56">特殊的排序算法</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_57">剑指 Offer 45. 把数组排成最小的数</a>
        </li>
</ul>        </div>
    <div class="rings" style="bottom: 0px;"></div>
</div>
                    </div>
                    <div class="clear"></div>
                </div>
                <div class="roundbottom"></div>
            </div>
        </div>
        <div class="footer">
            <div class="footer-icon"><div class="left" id="statistic">
    <span>
        浏览数：
        <span class='error-msg'>
            <span data-uvstaturl="https://gyyspace.github.io">0</span>
        </span>
        &nbsp;&nbsp;
    </span>
    <span>
        文章总数：
        <span class='error-msg'>
            15
        </span>
        &nbsp;&nbsp;
    </span>
</div>
<div class="clear"></div>
</div>
<div class="info">
    <div class="copyright">
        <br>
        <span>&copy; 2024</span> <a href="https://gyyspace.github.io">echo洋</a> 
    </div>
    <div class="right goTop">
        <span onclick="Util.goTop();">顶部</span>
    </div>
</div>
<script>
  var Label = {
    speech: true,
    servePath: "https://gyyspace.github.io",
    staticServePath: "https://gyyspace.github.io",
    luteAvailable: false,
    hljsStyle: 'github',
    langLabel: "zh_CN",
    version: "4.4.0",
    staticSite: true,
    showCodeBlockLn: false,
    articleId: "1721546193766",
  }
</script>
<script type="text/javascript" src="https://gyyspace.github.io/js/common.min.js?1721540580809" charset="utf-8"></script>
<script type="text/javascript">
    $(document).ready(function () {
        Util.setTopBar()
    });
</script>

        </div>
<script type="text/javascript">
    Util.addScript('https://gyyspace.github.io/js/page.min.js?1721540580809', 'soloPageScript')
    var page = new Page({
        "commentContentCannotEmptyLabel": "评论不能为空",
        "oId": "1721546193766",
        "blogHost": "https://gyyspace.github.io",
        "randomArticles1Label": "随机阅读：",
        "externalRelevantArticles1Label": "站外相关阅读："
    });
    $(document).ready(function () {
        page.load();
        page.tips.externalRelevantArticlesDisplayCount = "0";
        page.loadRandomArticles();
        page.loadRelevantArticles('1721546193766', '<h4>相关阅读：</h4>');
    });
</script>
    </body>
</html>

<!-- Generated by Latke (https://github.com/88250/latke) in 20ms, 2024/07/21 16:16:34 -->